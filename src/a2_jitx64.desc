// the A2 JIT for x64 CPU.

|.arch x64
|.actionlist actions

//-----------------------------------------------------------------------
// the vm and a2_obj struct operation
//-----------------------------------------------------------------------
|// a2_vm struct  map 
|.type A2_VM, struct a2_vm, r15  // struct a2_vm 
|.type SF_P, struct a2_obj, rbx  // the stack frame addr
|.define CURR_PC, r10            // the current pc

// object map
|.type R_OBJ1, struct a2_obj, r14 
|.type R_OBJ2, struct a2_obj, r13
|.type R_OBJ3, struct a2_obj, r12
|.type R_UV1, struct a2_upvalue, r11


|// set a2_vm addr
|.macro set_vm, p
|	mov64 A2_VM, (uintptr_t)p
|.endmacro

|// get stack frame head addr
|.macro get_sf
|	mov SF_P, A2_VM->stack_frame.sf_p
|.endmacro

|// get curr_pc
|.macro get_pc
| mov64 CURR_PC, (uintptr_t)curr_pc
|.endmacro

 // inc curr_pc
|.macro inc_pc
| inc CURR_PC
|.endmacro

// write curr_pc
|.macro write_pc
| mov A2_VM[0].call_chain[0].pc, CURR_PC
|.endmacro

|.define OBJ_SIZE, sizeof(struct a2_obj)

|// copy object
|.macro copy_obj, D, S, R1, R2
|	mov R1, S.type; mov64 R2, (uintptr_t)(S.value.point)
|	mov D.type, R1; mov D.value.point, R2 
|.endmacro
|.macro copy_obj, D, S; copy_obj D, S, ecx, rdx; .endmacro

|// copy register object
|.macro copy_Robj, D, S, R1, R2
| mov R1, S.type; mov R2, S.value.point
| mov D.type, R1; mov D.value.point, R2 
|.endmacro
|.macro copy_Robj, D, S; copy_Robj D, S, ecx, rdx; .endmacro

|// copy a2 object to stack frame by sf index
|.macro obj2sf, sf_idx, obj_p
|	copy_obj SF_P[sf_idx], (*obj_p)
|.endmacro

|.macro reg_obj2sf, sf_idx, R1
| copy_Robj SF_P[sf_idx], R1[0]
|.endmacro

// set nil for a2 object
|.macro nil4obj, obj
| mov ecx, A2_TNIL; mov64 rdx, (uintptr_t)NULL
| mov obj->type, ecx; mov obj->value.point, rdx
|.endmacro

// get a a2_obj address with sf_idx from stack frame
// the address will save R1 register
|.macro sf_obj, sf_idx, R1
| mov R1, SF_P; add R1, sf_idx*OBJ_SIZE
|.endmacro

// compare the a2_obj type
|.macro cmp_type, R_OBJ, t
| mov eax, R_OBJ->type
| cmp eax, t
|.endmacro


// get a value from stack frame or const stack
// the address will save R1 register
|.macro get_value, idx, R1
|| if(idx<0){ // the const value
||   struct a2_obj* obj = a2_closure_const((curr_cls), (idx));
|    mov64 R1, (uintptr_t)obj
|| }else{  // the stack frame 
||   size_t sf_idx = callinfo_sfi(curr_ci, idx);
|    sf_obj sf_idx, R1
|| }
|.endmacro

// get a a2_obj address with key from global map
// the address will save R2 register
|.macro get_envglobal, K, R2
| mov rdi, A2_VM->env_p // set env_p
| mov rsi, K
| callp a2_get_envglobal
| mov R2, rax
|.endmacro

// set a a2_obj address with key and value from global map
|.macro set_envglobal, K, V
| mov rdi, A2_VM->env_p
| mov rsi, K
| mov rdx, V
| callp a2_set_envglobal
|.endmacro


// the gcobject to upvalue obj
|.macro gcobj2upvalue, uv_obj, R1
| mov64 rdi, (uintptr_t)uv_obj
| callp a2_gcobj2upvalue
| mov R1, rax
|.endmacro

// call a function with a arg
|.macro callp, addr
| mov64  rax, (uintptr_t)addr
| call   rax
|.endmacro

//----------- dynasm operator function ------------
// dynasm struct 
#include <sys/mman.h>
static dasm_State *state = NULL;
size_t maxpc = 0;
#define Dst &state
typedef void(*dynasm_func)();

void a2_dynasm_new(dasm_State **state, const void *actionlist){
  dasm_init(state, 1);
  dasm_setup(state, actionlist);
}

void a2_dynasm_free(dasm_State **state){
	dasm_free(state);
  maxpc = 0;
}

dynasm_func a2_jitcode_new(dasm_State **state) {
  size_t size;
  a2_assert(dasm_link(state, &size), ==, DASM_S_OK);

  // Allocate memory readable and writable so we can
  // write the encoded instructions there.
  char *mem = (char*)mmap(NULL, size + sizeof(size_t),
		   PROT_READ | PROT_WRITE,
                   MAP_ANON | MAP_PRIVATE, -1, 0);
  assert(mem != MAP_FAILED);

  // Store length at the beginning of the region, so we
  // can free it without additional context.
  *(size_t*)mem = size;
  void *ret = mem + sizeof(size_t);

  dasm_encode(state, ret);

  // Adjust the memory permissions so it is executable
  // but no longer writable.
  a2_assert(mprotect(mem, size, PROT_EXEC | PROT_READ), ==, 0);
  return ret;
}

void a2_jitcode_free(dynasm_func code){
  void *mem = (char*)code - sizeof(size_t);
  a2_assert(munmap(mem, *(size_t*)mem), ==, 0);
}


//-----------------------------------------------------------------------
// dynasm operator function for test 
//-----------------------------------------------------------------------
void pt(void* p){
  printf("point = %p\n", p);
}

void look(){
  printf("look here!\n");
}

//-----------------------------------------------------------------------
// dynasm operator function for head 
//-----------------------------------------------------------------------
static void _per(struct a2_vm* vm_p){
  a2_dynasm_new(&state, actions);
  // init vm & stack frame
  | push rbp
  |//---------back register--------------
  | push A2_VM
  | push SF_P
  | push CURR_PC
  | push R_OBJ1
  | push R_OBJ2
  | push R_OBJ3
  | push R_UV1
  | push rax
  | push rcx
  | push rdx
  | push rsi
  | push rdi
  | mov rbp, rsp
  |//---------set vm register-------------
  | set_vm, vm_p
  | get_sf
  | get_pc
}

static dynasm_func _end(struct a2_vm* vm_p){
  |//---------recover register-----------
  | pop rdi
  | pop rsi
  | pop rdx
  | pop rcx
  | pop rax
  | pop R_UV1
  | pop R_OBJ3
  | pop R_OBJ2
  | pop R_OBJ1
  | pop CURR_PC
  | pop SF_P
  | pop A2_VM
  | pop rbp
  |//---------write pc-----------------
  | write_pc
  | ret

  // get dynasm func
  dynasm_func fptr = a2_jitcode_new(&state);
  a2_dynasm_free(&state);
  // fptr();
  // a2_jitcode_free(fptr);
  return fptr;
}

//-----------------------------------------------------------------------
// the load opcode 
//-----------------------------------------------------------------------
// load
static void _jit_load(struct a2_vm* vm_p){
	size_t sf_idx = callinfo_sfi(curr_ci, ir_ga(curr_ir));
	struct a2_obj* src_obj = a2_closure_const(curr_cls, ir_gbx(curr_ir));

  | obj2sf sf_idx, src_obj
  | inc_pc
}

// load nil 
static void _jit_loadnil(struct a2_vm* vm_p){
  size_t begin_sf_idx = callinfo_sfi(curr_ci, ir_ga(curr_ir));
  size_t end_sf_idx = begin_sf_idx+ir_gbx(curr_ir);

  // add label
  dasm_growpc(&state, maxpc+=2);
  |.define  SF_TP, R_OBJ1   // set stack frame pointer
  |.define  END_TP, R_OBJ2   
  | mov64 END_TP, (uintptr_t)(vm_p->stack_frame.sf_p+end_sf_idx)  // end ptr
  | mov SF_TP, SF_P
  | add SF_TP, OBJ_SIZE*begin_sf_idx  // begin ptr
  |=>(maxpc-2):           // loop begin
  | cmp SF_TP, END_TP
  | je  =>(maxpc-1)       // if end, so break
  | nil4obj SF_TP         // set nil for object 
  | add SF_TP, OBJ_SIZE
  | jmp =>(maxpc-2)       // next loop
  |=>(maxpc-1): 
  | inc_pc
}

//-----------------------------------------------------------------------
// the get /set global
//-----------------------------------------------------------------------
// get global
static void _jit_getglobal_error(struct a2_vm* vm_p, struct a2_obj* k){
  char _buf[64] = {0};
  a2_error(vm_p->env_p, e_vm_error, 
    "[vm error@%zd]: the global \'%s\' is not find.\n", 
    curr_line, 
    obj2str(k, _buf, sizeof(_buf)));
}

static void _jit_getglobal(struct a2_vm* vm_p){
  size_t des_sf_idx = callinfo_sfi(curr_ci, ir_ga(curr_ir));
  int idx = ir_gbx(curr_ir);

  dasm_growpc(&state, maxpc+=1);
  | get_value idx, R_OBJ1      // get key obj
  | get_envglobal R_OBJ1, R_OBJ2  // get global obj
  | cmp R_OBJ2, 0              
  | jne =>(maxpc-1)
  | mov rdi, A2_VM           // not find the key 
  | mov rsi, R_OBJ1
  | write_pc 
  | callp _jit_getglobal_error
  |=>(maxpc-1):
  | reg_obj2sf des_sf_idx, R_OBJ2   // set global value
  | inc_pc

}

// set global
static void _jit_setglobal(struct a2_vm* vm_p){
  int k_idx = ir_gb(curr_ir);
  int v_idx = ir_gc(curr_ir);
  size_t des_sf_idx = callinfo_sfi(curr_ci, ir_ga(curr_ir));

  | get_value k_idx, R_OBJ1        // get key obj
  | get_value v_idx, R_OBJ2        // get value obj
  | set_envglobal R_OBJ1, R_OBJ2      // set global 
  | reg_obj2sf des_sf_idx, R_OBJ2  // copy to stack frame
  | inc_pc
}

//-----------------------------------------------------------------------
// the get / set upvalue 
//-----------------------------------------------------------------------
// get upvalue
static void _jit_getupvalue(struct a2_vm* vm_p){
  struct a2_upvalue* _uv = a2_closure_upvalue(curr_cls, ir_gbx(curr_ir));
  size_t des_sf_idx = callinfo_sfi(curr_ci, ir_ga(curr_ir));

  dasm_growpc(&state, maxpc+=2);
  | mov eax, _uv->type
  | cmp eax, uv_stack
  | jne =>(maxpc-1)
  | sf_obj _uv->v.sf_idx, R_OBJ1
  | reg_obj2sf des_sf_idx, R_OBJ1      // internal copy from stack frame
  | jmp =>(maxpc-2)
  |=>(maxpc-1):
  | cmp eax, uv_gc
  | jne =>(maxpc-2) 
  | gcobj2upvalue _uv->v.uv_obj, R_OBJ1
  | reg_obj2sf des_sf_idx, R_OBJ1      // copy to stack frame from upvalue
  |=>(maxpc-2):
  | inc_pc
}

// set upvalue
static void _jit_setupvalue(struct a2_vm* vm_p){
  struct a2_upvalue* _uv_d = a2_closure_upvalue(curr_cls, ir_ga(curr_ir));
  int idx = ir_gbx(curr_ir);

  dasm_growpc(&state, maxpc+=2);
  | get_value idx, R_OBJ1  // get value
  | mov eax, _uv_d->type
  | cmp eax, uv_gc
  | jne =>(maxpc-1)
  | gcobj2upvalue _uv_d->v.uv_obj, R_OBJ2
  | copy_Robj R_OBJ2[0], R_OBJ1[0]
  | jmp =>(maxpc-2)
  |=>(maxpc-1):
  | cmp eax, uv_stack
  | jne =>(maxpc-2)
  | reg_obj2sf _uv_d->v.sf_idx, R_OBJ1 // set stack frame value   
  |=>(maxpc-2):
  | inc_pc
}


//-----------------------------------------------------------------------
// the error list 
//-----------------------------------------------------------------------
static void _gv_type_error(struct a2_vm* vm_p){
  vm_error("the varable is not map or array.");
}
static void _gk_array_error(struct a2_vm* vm_p){
  vm_error("the key is must number at array.");
}
static void _gk_map_error(struct a2_vm* vm_p){
  vm_error("the key is must number or string at map.");
}
static void _gv_error(struct a2_vm* vm_p){
  vm_error("the key is overfllow.");
}
static void _opt_error(struct a2_vm* vm_p){
  vm_error("the varable is not number.");
}

// call error
|.macro call_error, func
| mov rdi, A2_VM
| write_pc
| callp func
|.endmacro

//-----------------------------------------------------------------------
//  get / set value
//-----------------------------------------------------------------------
|.macro obj2container, func, R_OBJ, R2
| mov rdi, R_OBJ->value.obj
| callp func
| mov R2, rax
|.endmacro

|.macro container_get, func, R_C, R_K, R2
| mov rdi, R_C
| mov rsi, R_K
| callp func
| mov R2, rax
|.endmacro

// get array with index
|.macro get_array, R_C, R_K, R2
| obj2container a2_gcobj2array, R_C, R_C
| container_get a2_array_get, R_C, R_K, R2
|.endmacro

// get map with index
|.macro get_map, R_C, R_K, R2
| obj2container a2_gcobj2map, R_C, R_C
| container_get a2_map_query, R_C, R_K, R2
|.endmacro

// the container operator
|.macro container_oper, c_sf_idx, k_idx, op_macro
|| dasm_growpc(&state, maxpc+=6); 
| sf_obj c_sf_idx,   R_OBJ2       // get container
| get_value  k_idx,  R_OBJ3       // get key
| cmp_type R_OBJ2, A2_TARRAY      // if array
| jne =>(maxpc-1)
| cmp_type R_OBJ3, A2_TNUMBER 
| je =>(maxpc-3)
| call_error _gk_array_error    // if key not number
|=>(maxpc-3):
|  get_array R_OBJ2, R_OBJ3, R_OBJ1
| cmp R_OBJ1, NULL
| je =>(maxpc-4)
| op_macro
| jmp =>(maxpc-5)
|=>(maxpc-1):
| cmp_type R_OBJ2, A2_TMAP      // if map
| jne =>(maxpc-2)
| cmp_type R_OBJ3, A2_TNUMBER
| je =>(maxpc-6)
| cmp_type R_OBJ3, A2_TSTRING
| je =>(maxpc-6)
| call_error _gk_map_error   // if key not number & string
|=>(maxpc-6):
| get_map R_OBJ2, R_OBJ3, R_OBJ1
| cmp R_OBJ1, 0
| je =>(maxpc-4)
| op_macro
| jmp =>(maxpc-5)
|=>(maxpc-2):
| call_error _gv_type_error    // if the type not array and map 
|=>(maxpc-4):
| call_error _gv_error // not get value
|=>(maxpc-5):
|.endmacro

static void _jit_getvalue(struct a2_vm* vm_p){
  size_t des_sf_idx = callinfo_sfi(curr_ci, ir_ga(curr_ir));
  size_t c_sf_idx = callinfo_sfi(curr_ci, ir_gb(curr_ir));
  int k_idx = ir_gc(curr_ir);

  |.macro get_op
  | reg_obj2sf des_sf_idx, R_OBJ1
  |.endmacro


  | container_oper c_sf_idx, k_idx, get_op
  | inc_pc
}

static void _jit_setvalue(struct a2_vm* vm_p){
  size_t c_sf_idx = callinfo_sfi(curr_ci, ir_ga(curr_ir));
  int k_idx = ir_gb(curr_ir);
  int v_idx = ir_gc(curr_ir);

  |.macro set_op
  | get_value v_idx, R_OBJ2
  | copy_Robj R_OBJ1[0], R_OBJ2[0]
  |.endmacro

  | container_oper c_sf_idx, k_idx, set_op
  | inc_pc
}


//-----------------------------------------------------------------------
// arithmetical and > < >= <= operatior 
//-----------------------------------------------------------------------
|.macro arithmetical_op, op_macro, tt
||size_t des_sf_idx = callinfo_sfi(curr_ci, ir_ga(curr_ir));
||int a_idx = ir_gb(curr_ir);
||int b_idx = ir_gc(curr_ir);
||dasm_growpc(&state, maxpc+=2);
| get_value a_idx, R_OBJ1
| get_value b_idx, R_OBJ2
| cmp_type R_OBJ1, A2_TNUMBER 
| jne =>(maxpc-1)
| cmp_type R_OBJ2, A2_TNUMBER
| jne =>(maxpc-1)                  // if obj1 or obj2 not number type
| mov rax, R_OBJ1->value.number
| movd xmm0, rax
| mov rax, R_OBJ2->value.number
| movd xmm1, rax
| op_macro xmm0, xmm1
| movd rax, xmm0
| sf_obj des_sf_idx, R_OBJ1       // get des obj ptr
| mov ecx, tt
| mov R_OBJ1[0].type, ecx
| mov R_OBJ1[0].value.number, rax // set add value
| jmp =>(maxpc-2)
|=>(maxpc-1):
| call_error _opt_error
|=>(maxpc-2):
|.endmacro

// jit add 
static void _jit_add(struct a2_vm* vm_p){
  |.macro add_op, X1, X2
  | addsd X1, X2
  |.endmacro

  | arithmetical_op add_op, A2_TNUMBER
  | inc_pc
}

// jit sub 
static void _jit_sub(struct a2_vm* vm_p){
  |.macro sub_op, X1, X2
  | subsd X1, X2
  |.endmacro

  | arithmetical_op sub_op, A2_TNUMBER
  | inc_pc
}

// jit div
static void _jit_div(struct a2_vm* vm_p){
  |.macro div_op, X1, X2
  | divsd X1, X2
  |.endmacro

  | arithmetical_op div_op, A2_TNUMBER
  | inc_pc
}

// jit mul
static void _jit_mul(struct a2_vm* vm_p){
  |.macro mul_op, X1, X2
  | mulsd X1, X2
  |.endmacro

  | arithmetical_op mul_op, A2_TNUMBER
  | inc_pc
}

// jit big
static void _jit_big(struct a2_vm* vm_p){
  |.macro big_op, X1, X2
  | ucomisd X1, X2
  | seta al
  | and al, 1
  | movzx rax, al
  | movd X1, rax
  |.endmacro

  |  arithmetical_op big_op, A2_TBOOL
  | inc_pc
} 

// jit lite
static void _jit_lite(struct a2_vm* vm_p){
  |.macro lite_op, X1, X2
  | ucomisd X2, X1
  | seta al
  | and al, 1
  | movzx rax, al
  | movd X1, rax
  |.endmacro

  |  arithmetical_op lite_op, A2_TBOOL
  | inc_pc
}


// jit bige
static void _jit_bige(struct a2_vm* vm_p){
  |.macro bige_op, X1, X2
  | ucomisd X1, X2
  | setae al
  | and al, 1
  | movzx rax, al
  | movd X1, rax
  |.endmacro

  |  arithmetical_op bige_op, A2_TBOOL
  | inc_pc
}


// jit litee
static void _jit_litee(struct a2_vm* vm_p){
  |.macro litee_op, X1, X2
  | ucomisd X2, X1
  | setae al
  | and al, 1
  | movzx rax, al
  | movd X1, rax
  |.endmacro


  |  arithmetical_op litee_op, A2_TBOOL
  | inc_pc
}

//-----------------------------------------------------------------------
// jit move 
//-----------------------------------------------------------------------
static void _jit_move(struct a2_vm* vm_p){
  size_t des_sf_idx = callinfo_sfi(curr_ci, ir_ga(curr_ir));
  size_t src_sf_idx = callinfo_sfi(curr_ci, ir_gbx(curr_ir));

  | sf_obj src_sf_idx, R_OBJ1
  | reg_obj2sf des_sf_idx, R_OBJ1
  | inc_pc
}


//-----------------------------------------------------------------------
// not jit opcode 
//-----------------------------------------------------------------------
typedef void(*inter_func)(struct a2_vm*);
static void _njit_func(struct a2_vm* vm_p, inter_func func){
  | mov64 rdi, (uintptr_t)vm_p
  | write_pc
  | callp func   // call interpreter function 
}

static void _njit_or(struct a2_vm* vm_p){
  _vm_opl(||);
  curr_pc++;
}

static void _njit_and(struct a2_vm* vm_p){
  _vm_opl(&&);
  curr_pc++;
}

static void _njit_equ(struct a2_vm* vm_p){
  _vm_ope(!=);
  curr_pc++;
}

static void _njit_nequ(struct a2_vm* vm_p){
  _vm_ope(!=);
  curr_pc++;
}

// not - not jit
#define _njit_not(vm_p)    _njit_func(vm_p, _vm_not)

// neg - not jit
#define _njit_neg(vm_p)    _njit_func(vm_p, _vm_neg)

// cat - not jit
#define _njit_cat(vm_p)   _njit_func(vm_p, _vm_cat)

// set list - not jit
#define _njit_setlist(vm_p) _njit_func(vm_p, _vm_setlist)

// set map - not jit
#define _njit_setmap(vm_p) _njit_func(vm_p, _vm_setmap)

// new list - not jit 
#define _njit_newlist(vm_p) _njit_func(vm_p, _vm_newlist)

// new map - not jit
#define _njit_newmap(vm_p) _njit_func(vm_p, _vm_newmap)

// closure - not jit
#define _njit_closure(vm_p) _njit_func(vm_p, _vm_closure) 


//-----------------------------------------------------------------------
// jit build, the treace is function  
//-----------------------------------------------------------------------

static dynasm_func _jit_build(struct a2_vm* vm_p){
  size_t i;
  _per(vm_p);
  for(i=0; i<a2_closure_ircount(curr_cls); i++){
    ir _ir = a2_closure_ir(curr_cls, i);
    switch(ir_gop(_ir)){
      case LOAD:
        _jit_load(vm_p);
        break;
      case LOADNIL:
        _jit_loadnil(vm_p);
        break;
      case GETGLOBAL:
        _jit_getglobal(vm_p);
        break;
      case SETGLOBAL:
        _jit_setglobal(vm_p);
        break;
      case GETUPVALUE:
        _jit_getupvalue(vm_p);
        break;
      case SETUPVALUE:
        _jit_setupvalue(vm_p);
        break;
      case NEWLIST:
        _njit_newlist(vm_p);
        break;
      case NEWMAP:
        _njit_newmap(vm_p);
        break;
      case GETVALUE:
        _jit_getvalue(vm_p);
        break;
      case SETVALUE:
        _jit_setvalue(vm_p);
        break;
      case SETLIST:
        _njit_setlist(vm_p);
        break;
      case SETMAP:
        _njit_setmap(vm_p);
        break;
      case CLOSURE:
        _njit_closure(vm_p);
        break;
      case MOVE:
        _jit_move(vm_p);
        break;
      case ADD:
        _jit_add(vm_p);
        break;
      case SUB:
        _jit_sub(vm_p);
        break;
      case DIV:
        _jit_div(vm_p);
        break;
      case MUL:
        _jit_mul(vm_p);
        break;
      case OR:
        _njit_or(vm_p);
        break;
      case AND:
        _njit_and(vm_p);
        break;
      case BIG:
        _jit_big(vm_p);
        break;
      case LITE:
        _jit_lite(vm_p);
        break;
      case BIGE:
        _jit_bige(vm_p);
        break;
      case LITEE:
        _jit_litee(vm_p);
        break;
      case EQU:
        _njit_equ(vm_p);
        break;
      case NEQU:
        _njit_nequ(vm_p);
        break;
      case NOT:
        _njit_not(vm_p);
        break;
      case NEG:
        _njit_neg(vm_p);
        break;
      case CAT:
        _njit_cat(vm_p);
        break;
      default:
        assert(0);
    }
  }

  dynasm_func asm_func = _end(vm_p);
  return asm_func;
}

static void _jit_clear(dynasm_func asm_func){
  a2_jitcode_free(asm_func);
}


